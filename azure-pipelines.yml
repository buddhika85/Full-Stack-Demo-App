trigger:
- main                          # Tells Azure DevOps to run the pipeline whenever code is pushed to the main branch.-----------------------------------

variables:
- group: vg-interview-demo      # Variable group containing secrets and config values

# ----------------------------
# Uses 3 jobs across 1 stage:
# JOB 1 - CI + API + DB (Windows agent)
# JOB 2 - Angular Build (Windows agent)
# JOB 3 - Angular Deployment (Linux agent)
# ----------------------------

stages:
- stage: BuildAndDeploy
  displayName: 'CI/CD Pipeline'
  jobs:

  # ----------------------------
  # JOB 1 - CI steps 1 to 14
  # ----------------------------
  - job: CI_Backend
    displayName: 'Build, Test, Deploy API + DB'
    pool:
      vmImage: 'windows-latest'
    steps:

    # 1. CI ‚Äî Install .NET 9 SDK explicitly
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '9.0.304'   # exact version from my DEV machine
        includePreviewVersions: true
        installationPath: $(Agent.ToolsDirectory)/dotnet

    # 2. CI ‚Äî Install NugetCLI for restoring packages
    - task: NuGetToolInstaller@1

    # 3. CI ‚Äî Restore NuGet packages - all dependencies defined in Backend.sln are installed
    - task: NuGetCommand@2
      inputs:
        command: 'restore'
        restoreSolution: 'Backend/Backend.sln'

    # 4. CI ‚Äî Build solution - compiles all projects in Release mode
    - task: DotNetCoreCLI@2
      inputs:
        command: 'build'
        projects: 'Backend/Backend.sln'
        arguments: '--configuration Release'

    # 5. CI ‚Äî Run XUnit tests with TRX logger + collect coverage
    - task: DotNetCoreCLI@2
      inputs:
        command: 'test'
        projects: 'Backend/Emp.XUnitTests/*.csproj'
        arguments: '--configuration Release --no-build --no-restore --collect:"XPlat Code Coverage" --logger "trx;LogFileName=test-results.trx"'
        publishTestResults: false                                   # We'll handle publishing ourselves

    # 6. CI ‚Äî Publish test results
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/TestResults/test-results.trx'         # test results in /TestResults/test-results.trx
        failTaskOnFailedTests: true                                 # ensures the pipeline fails if any test fails.
      condition: succeededOrFailed()                                # ensures results are published even if tests fail.

    # 7. CI ‚Äî Publish coverage
    - task: PublishCodeCoverageResults@2                            # Picks up coverage.cobertura.xml and shows coverage % in DevOps summary.
      inputs:
        codeCoverageTool: 'cobertura'
        summaryFileLocation: '$(System.DefaultWorkingDirectory)/**/coverage.cobertura.xml'
        reportDirectory: '$(System.DefaultWorkingDirectory)/**'
      condition: succeededOrFailed()

    # 8. CI ‚Äî Publish HTML coverage report as artifact
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: 'Backend/Emp.XUnitTests/TestResults'         # Explicit path to TestResults folder
        ArtifactName: 'coverage-report'
        publishLocation: 'Container'
      condition: succeededOrFailed()

    # 9. CD ‚Äî Publish Backend API to generate ZIP for Azure deployment
    - task: DotNetCoreCLI@2
      displayName: 'Publish Backend API'
      inputs:
        command: 'publish'
        projects: 'Backend/Emp.Api/Emp.Api.csproj'
        arguments: '--configuration Release --output $(Build.ArtifactStagingDirectory)/api'
      
    # Verify Published API Contents - Emp.Api.DLL, swagger/index.html, swagger/v1/swagger.json must be present
    - task: PowerShell@2
      displayName: 'Verify Published API Contents'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "üîç Verifying published API contents:"
          Get-ChildItem "$(Build.ArtifactStagingDirectory)/api" -Recurse | Select-String -Pattern "Emp.Api.dll|swagger"

    # 10. CD ‚Äî Deploy Backend API
    - task: AzureWebApp@1
      displayName: 'Deploy API to Azure App Service'
      inputs:
        azureSubscription: 'sc-azure-rg-interview-demo'             # ARM service connection in DevOps
        appName: 'api-interview-demo'                               # Name of the Backend Azure App Service
        package: '$(Build.ArtifactStagingDirectory)/api/Emp.Api.zip'
        
    # 11. List contents of published API artifact
    - task: PowerShell@2
      displayName: 'List API Artifact Contents'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "üì¶ Listing contents of published API artifact:"
          Get-ChildItem "$(Build.ArtifactStagingDirectory)/api" -Recurse
    
    # Inspect contents of Emp.Api.zip to confirm Swagger JSON is included    
    - task: PowerShell@2
      displayName: 'Inspect ZIP Contents'
      inputs:
        targetType: 'inline'
        script: |
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $zipPath = "$(Build.ArtifactStagingDirectory)/api/Emp.Api.zip"
          $zip = [System.IO.Compression.ZipFile]::OpenRead($zipPath)
          foreach ($entry in $zip.Entries) {
            Write-Host $entry.FullName
          }
          $zip.Dispose()

    # 12. Post-deploy health check for Swagger JSON
    - task: PowerShell@2
      displayName: 'Check Swagger JSON Availability'
      inputs:
        targetType: 'inline'
        script: |
          $url = "https://api-interview-demo-gug3dwcbecg7emb6.australiaeast-01.azurewebsites.net/swagger/v1/swagger.json"
          Write-Host "üåê Checking Swagger endpoint: $url"
          try {
            $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10
            if ($response.StatusCode -eq 200) {
              Write-Host "‚úÖ Swagger JSON is available."
            } else {
              Write-Error "‚ùå Swagger JSON returned status code $($response.StatusCode)"
              exit 1
            }
          } catch {
            Write-Error "‚ùå Failed to reach Swagger JSON: $($_.Exception.Message)"
            exit 1
          }

    # 13. CD ‚Äî Use local dotnet-ef tool via manifest
    # Creates a local manifest file
    # Use exact version to avoid ambiguity
    - script: |
        dotnet new tool-manifest --force                                                               
        dotnet tool install dotnet-ef --version 9.0.7                                 
        echo ##vso[task.prependpath]$(System.DefaultWorkingDirectory)/.config/dotnet-tools
      displayName: 'Install dotnet-ef as local tool (v9.0.7)'

    # 14. List pending EF Core migrations using local tool
    - script: |
        dotnet tool run dotnet-ef migrations list --project Backend/Emp.Api/Emp.Api.csproj --configuration Release
      displayName: 'List Pending EF Core Migrations'

    # 15. Apply EF Core migrations using local tool
    - script: |
        dotnet tool run dotnet-ef database update --project Backend/Emp.Api/Emp.Api.csproj --configuration Release --no-build
      displayName: 'Run EF Core Migrations'
      env:
        ConnectionStrings__DefaultConnection: '$(ConnectionStrings__DefaultConnection)'   # stored in pipeline variables
        
        
        




  # ----------------------------
  # JOB 2 - Angular SPA Build (Windows agent)
  # ----------------------------
  - job: BuildAngular
    displayName: 'Build Angular App'
    pool:
      vmImage: 'windows-latest'
    steps:
      - task: NodeTool@0
        inputs:
          versionSpec: '20.x'

      # Step 1 ‚Äî Build Angular app using PowerShell for reliable execution
      # Explicitly set output path to dist/debug-check to avoid ambiguity
      - task: PowerShell@2
        displayName: 'Build Angular App and List Output'
        inputs:
          targetType: 'inline'
          script: |
            cd "$(Build.SourcesDirectory)\Emp.Angular"
            npm install
            npx ng build -c production --output-path=dist/debug-check
            Write-Host "‚úÖ Build completed. Listing contents:"
            Get-ChildItem "dist/debug-check" -Recurse

      # Step 2 ‚Äî Recursively list contents of dist/debug-check folder to confirm actual output structure
      - task: PowerShell@2
        displayName: 'Recursively list Angular dist/debug-check contents'
        inputs:
          targetType: 'inline'
          script: |
            Get-ChildItem "$(Build.SourcesDirectory)\Emp.Angular\dist\debug-check" -Recurse

      # Step 3 ‚Äî Fallback check to avoid pipeline failure if dist/debug-check folder is missing
      - task: PowerShell@2
        displayName: 'Check if Angular dist/debug-check folder exists'
        inputs:
          targetType: 'inline'
          script: |
            if (Test-Path "$(Build.SourcesDirectory)\Emp.Angular\dist\debug-check") {
              Write-Host "‚úÖ Angular dist/debug-check folder found."
            } else {
              Write-Host "‚ùå Angular dist/debug-check folder not found. Check build output."
            }

      # ‚úÖ Final fix ‚Äî publish everything inside dist/debug-check/browser folder
      - task: PublishBuildArtifacts@1
        inputs:
          PathtoPublish: '$(Build.SourcesDirectory)/Emp.Angular/dist/debug-check/browser'          # ‚úÖ Corrected path to compiled Angular output
          ArtifactName: 'angular-dist'
          publishLocation: 'Container'








  # ----------------------------
  # JOB 3 - Angular SPA Deploy (Linux Agent)
  # ----------------------------
  - job: DeployAngular
    displayName: 'Deploy Angular to Azure Static Web Apps'
    dependsOn: BuildAngular
    condition: succeeded()                                           # Ensures deployment only runs if build succeeds
    pool:
      vmImage: 'ubuntu-latest'
    steps:
      # ‚úÖ Download artifact to repo-relative path
      # This ensures the deployment task can detect the folder correctly
      - task: DownloadPipelineArtifact@2
        inputs:
          artifact: angular-dist
          targetPath: 'angular-dist'                                 # ‚úÖ Relative to $(System.DefaultWorkingDirectory)

      # ‚úÖ Verify contents of downloaded artifact before deployment
      # Confirms index.html and static assets are present
      - script: ls $(System.DefaultWorkingDirectory)/angular-dist
        displayName: 'Verify downloaded Angular artifact contents'

      # ‚úÖ Deploy pre-built Angular app using AzureStaticWebApp@0
      # app_location must be relative to repo root ‚Äî absolute paths will fail
      # skip_app_build: true disables Oryx build since app is already built
      # output_location: '' is required when skipping build
      - task: AzureStaticWebApp@0
        inputs:
          app_location: 'angular-dist'                               # ‚úÖ Relative path from repo root
          skip_app_build: true                                       # Skip Oryx build
          output_location: ''                                        # Required when skipping build
          azure_static_web_apps_api_token: '$(SWA_DEPLOYMENT_TOKEN)' # Deployment token from pipeline variables