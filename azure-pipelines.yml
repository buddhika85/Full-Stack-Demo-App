trigger:
- main                          # Tells Azure DevOps to run the pipeline whenever code is pushed to the main branch.-----------------------------------

variables:
- group: vg-interview-demo      # Variable group containing secrets and config values

# ----------------------------
# Uses 3 jobs across 1 stage:
# JOB 1 - CI + API + DB (Windows agent)
# JOB 2 - Angular Build (Windows agent)
# JOB 3 - Angular Deployment (Linux agent)
# ----------------------------

stages:
- stage: BuildAndDeploy
  displayName: 'CI/CD Pipeline'
  jobs:

  # ----------------------------
  # JOB 1 - CI steps 1 to 14
  # ----------------------------
  - job: CI_Backend
    displayName: 'Build, Test, Deploy API + DB'
    pool:
      vmImage: 'windows-latest'
    steps:

    # 1. CI ‚Äî Install .NET 9 SDK explicitly
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '9.0.304'   # exact version from my DEV machine
        includePreviewVersions: true
        installationPath: $(Agent.ToolsDirectory)/dotnet

    # 2. CI ‚Äî Install NugetCLI for restoring packages
    - task: NuGetToolInstaller@1

    # 3. CI ‚Äî Restore NuGet packages - all dependencies defined in Backend.sln are installed
    - task: NuGetCommand@2
      inputs:
        command: 'restore'
        restoreSolution: 'Backend/Backend.sln'

    # 4. CI ‚Äî Build solution - compiles all projects in Release mode
    - task: DotNetCoreCLI@2
      inputs:
        command: 'build'
        projects: 'Backend/Backend.sln'
        arguments: '--configuration Release'

    # 5. CI ‚Äî Run XUnit tests with TRX logger + collect coverage
    - task: DotNetCoreCLI@2
      inputs:
        command: 'test'
        projects: 'Backend/Emp.XUnitTests/*.csproj'
        arguments: '--configuration Release --no-build --no-restore --collect:"XPlat Code Coverage" --logger "trx;LogFileName=test-results.trx"'
        publishTestResults: false                                   # We'll handle publishing ourselves

    # 6. CI ‚Äî Publish test results
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/TestResults/test-results.trx'         # test results in /TestResults/test-results.trx
        failTaskOnFailedTests: true                                 # ensures the pipeline fails if any test fails.
      condition: succeededOrFailed()                                # ensures results are published even if tests fail.

    # 7. CI ‚Äî Publish coverage
    - task: PublishCodeCoverageResults@2                            # Picks up coverage.cobertura.xml and shows coverage % in DevOps summary.
      inputs:
        codeCoverageTool: 'cobertura'
        summaryFileLocation: '$(System.DefaultWorkingDirectory)/**/coverage.cobertura.xml'
        reportDirectory: '$(System.DefaultWorkingDirectory)/**'
      condition: succeededOrFailed()

    # 8. CI ‚Äî Publish HTML coverage report as artifact
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: 'Backend/Emp.XUnitTests/TestResults'         # Explicit path to TestResults folder
        ArtifactName: 'coverage-report'
        publishLocation: 'Container'
      condition: succeededOrFailed()

    # 9. CD ‚Äî Publish Backend API to generate ZIP for Azure deployment
    - task: DotNetCoreCLI@2
      displayName: 'Publish Backend API'
      inputs:
        command: 'publish'
        projects: 'Backend/Emp.Api/Emp.Api.csproj'
        arguments: '--configuration Release --output $(Build.ArtifactStagingDirectory)/api'
      
    # Verify Published API Contents - Emp.Api.DLL, swagger/index.html, swagger/v1/swagger.json must be present
    - task: PowerShell@2
      displayName: 'Verify Published API Contents'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "üîç Verifying published API contents:"
          Get-ChildItem "$(Build.ArtifactStagingDirectory)/api" -Recurse | Select-String -Pattern "Emp.Api.dll|swagger"

    # 10. CD ‚Äî Deploy Backend API
    - task: AzureWebApp@1
      displayName: 'Deploy API to Azure App Service'
      inputs:
        azureSubscription: 'sc-azure-rg-interview-demo'             # ARM service connection in DevOps
        appName: 'api-interview-demo'                               # Name of the Backend Azure App Service
        package: '$(Build.ArtifactStagingDirectory)/api/Emp.Api.zip'
        
    # 11. List contents of published API artifact
    - task: PowerShell@2
      displayName: 'List API Artifact Contents'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "üì¶ Listing contents of published API artifact:"
          Get-ChildItem "$(Build.ArtifactStagingDirectory)/api" -Recurse
    
    # Inspect contents of Emp.Api.zip to confirm Swagger JSON is included    
    - task: PowerShell@2
      displayName: 'Inspect ZIP Contents'
      inputs:
        targetType: 'inline'
        script: |
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $zipPath = "$(Build.ArtifactStagingDirectory)/api/Emp.Api.zip"
          $zip = [System.IO.Compression.ZipFile]::OpenRead($zipPath)
          foreach ($entry in $zip.Entries) {
            Write-Host $entry.FullName
          }
          $zip.Dispose()

    # 12. Post-deploy health check for Swagger JSON
    # - task: PowerShell@2
      # displayName: 'Check Swagger JSON Availability'
      # inputs:
        # targetType: 'inline'
        # script: |
          # $url = "https://api-interview-demo-gug3dwcbecg7emb6.australiaeast-01.azurewebsites.net/swagger/v1/swagger.json"
          # Write-Host "üåê Checking Swagger endpoint: $url"
          # try {
            # $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10
            # if ($response.StatusCode -eq 200) {
              # Write-Host "‚úÖ Swagger JSON is available."
            # } else {
              # Write-Error "‚ùå Swagger JSON returned status code $($response.StatusCode)"
              # exit 1
            # }
          # } catch {
            # Write-Error "‚ùå Failed to reach Swagger JSON: $($_.Exception.Message)"
            # exit 1
          # }

    # 13. CD ‚Äî Install dotnet-ef tool BEFORE using it for listing migrations
    # Installs EF CLI globally for .NET 9
    # Adds EF CLI to PATH so it's usable in next steps
    - script: |
        dotnet tool install --global dotnet-ef --prerelease          
        echo ##vso[task.prependpath]$HOME/.dotnet/tools             
      displayName: 'Install dotnet-ef tool'

    # 14. List pending EF Core migrations after tool is installed
    - script: |
        dotnet ef migrations list --project Backend/Emp.Api/Emp.Api.csproj --configuration Release
      displayName: 'List Pending EF Core Migrations'

    # 15. CD ‚Äî Apply EF Core migrations to Azure SQL DB
    - script: |
        dotnet ef database update --project Backend/Emp.Api/Emp.Api.csproj --configuration Release --no-build
      displayName: 'Run EF Core Migrations'
      env:
        ConnectionStrings__DefaultConnection: '$(ConnectionStrings__DefaultConnection)'   # stored in pipeline variables